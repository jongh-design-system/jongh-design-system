import ESM_COMPAT_Module from 'node:module';
import { fileURLToPath } from 'node:url';
import path, { dirname, normalize } from 'node:path';
import { TEST_PROVIDER_ID, log } from '../chunk-KHOSIC5P.mjs';
import '../chunk-EEU7V67W.mjs';
import '../chunk-HVK6626C.mjs';
import process2 from 'node:process';
import { Channel } from 'storybook/internal/channels';
import { TESTING_MODULE_RUN_REQUEST, TESTING_MODULE_RUN_ALL_REQUEST, TESTING_MODULE_WATCH_MODE_REQUEST, TESTING_MODULE_CANCEL_TEST_RUN_REQUEST, TESTING_MODULE_PROGRESS_REPORT } from 'storybook/internal/core-events';
import { existsSync } from 'node:fs';
import { getTests } from '@vitest/runner/utils';

const __filename = fileURLToPath(import.meta.url);
dirname(__filename);
ESM_COMPAT_Module.createRequire(import.meta.url);
function slash(path2){return path2.startsWith("\\\\?\\")?path2:path2.replace(/\\/g,"/")}function debounce(func,debounceMs,{signal,edges}={}){let pendingThis,pendingArgs=null,leading=edges!=null&&edges.includes("leading"),trailing=edges==null||edges.includes("trailing"),invoke=()=>{pendingArgs!==null&&(func.apply(pendingThis,pendingArgs),pendingThis=void 0,pendingArgs=null);},onTimerEnd=()=>{trailing&&invoke(),cancel();},timeoutId=null,schedule=()=>{timeoutId!=null&&clearTimeout(timeoutId),timeoutId=setTimeout(()=>{timeoutId=null,onTimerEnd();},debounceMs);},cancelTimer=()=>{timeoutId!==null&&(clearTimeout(timeoutId),timeoutId=null);},cancel=()=>{cancelTimer(),pendingThis=void 0,pendingArgs=null;},flush=()=>{cancelTimer(),invoke();},debounced=function(...args){if(signal?.aborted)return;pendingThis=this,pendingArgs=args;let isFirstCall=timeoutId==null;schedule(),leading&&isFirstCall&&invoke();};return debounced.schedule=schedule,debounced.cancel=cancel,debounced.flush=flush,signal?.addEventListener("abort",cancel,{once:!0}),debounced}function throttle(func,throttleMs,{signal,edges=["leading","trailing"]}={}){let pendingAt=null,debounced=debounce(func,throttleMs,{signal,edges}),throttled=function(...args){pendingAt==null?pendingAt=Date.now():Date.now()-pendingAt>=throttleMs&&(pendingAt=Date.now(),debounced.cancel(),debounced(...args)),debounced(...args);};return throttled.cancel=debounced.cancel,throttled.flush=debounced.flush,throttled}var StatusMap={fail:"failed",only:"pending",pass:"passed",run:"pending",skip:"skipped",todo:"todo"},StorybookReporter=class{constructor(testManager){this.testManager=testManager;this.testStatusData={};this.start=0;this.sendReport=throttle(payload=>this.testManager.sendProgressReport(payload),1e3);}onInit(ctx){this.ctx=ctx,this.start=Date.now();}getProgressReport(finishedAt){let files=this.ctx.state.getFiles(),fileTests=getTests(files),numTotalTests=fileTests.length,numFailedTests=fileTests.filter(t=>t.result?.state==="fail").length,numPassedTests=fileTests.filter(t=>t.result?.state==="pass").length,numPendingTests=fileTests.filter(t=>t.result?.state==="run"||t.mode==="skip"||t.result?.state==="skip").length,testResults=[];for(let file of files){let tests=getTests([file]),startTime=tests.reduce((prev,next)=>Math.min(prev,next.result?.startTime??Number.POSITIVE_INFINITY),Number.POSITIVE_INFINITY);startTime===Number.POSITIVE_INFINITY&&(startTime=this.start);let endTime=tests.reduce((prev,next)=>Math.max(prev,(next.result?.startTime??0)+(next.result?.duration??0)),startTime),assertionResults=tests.flatMap(t=>{let ancestorTitles=[],iter=t.suite;for(;iter;)ancestorTitles.push(iter.name),iter=iter.suite;ancestorTitles.reverse();let status=StatusMap[t.result?.state||t.mode]||"skipped",storyId=t.meta.storyId,duration=t.result?.duration||0,testRunId=this.start.toString();switch(status){case"passed":case"pending":return [{status,storyId,duration,testRunId}];case"failed":let failureMessages=t.result?.errors?.map(e=>e.stack||e.message)||[];return [{status,storyId,duration,failureMessages,testRunId}];default:return []}}),hasFailedTests=tests.some(t=>t.result?.state==="fail");testResults.push({results:assertionResults,startTime,endTime,status:file.result?.state==="fail"||hasFailedTests?"failed":"passed",message:file.result?.errors?.[0]?.stack||file.result?.errors?.[0]?.message});}return {cancellable:!finishedAt,progress:{numFailedTests,numPassedTests,numPendingTests,numTotalTests,startedAt:this.start,finishedAt},details:{testResults}}}async onTaskUpdate(){try{this.sendReport({providerId:TEST_PROVIDER_ID,status:"pending",...this.getProgressReport()});}catch(e){this.sendReport({providerId:TEST_PROVIDER_ID,status:"failed",error:e instanceof Error?{name:"Failed to gather test results",message:e.message,stack:e.stack}:{name:"Failed to gather test results",message:String(e)}});}}async clearVitestState(){this.ctx.state.filesMap.clear(),this.ctx.state.pathsSet.clear(),this.ctx.state.idMap.clear(),this.ctx.state.errorsSet.clear(),this.ctx.state.processTimeoutCauses.clear();}async onFinished(){let unhandledErrors=this.ctx.state.getUnhandledErrors(),isCancelled=this.ctx.isCancelling,report=this.getProgressReport(Date.now()),testSuiteFailures=report.details.testResults.filter(t=>t.status==="failed"&&t.results.length===0),reducedTestSuiteFailures=new Set;if(testSuiteFailures.forEach(t=>{reducedTestSuiteFailures.add(t.message);}),isCancelled)this.sendReport({providerId:TEST_PROVIDER_ID,status:"cancelled",...report});else if(reducedTestSuiteFailures.size>0||unhandledErrors.length>0){let error=reducedTestSuiteFailures.size>0?{name:`${reducedTestSuiteFailures.size} component ${reducedTestSuiteFailures.size===1?"test":"tests"} failed`,message:Array.from(reducedTestSuiteFailures).reduce((acc,curr)=>`${acc}
${curr}`,"")}:{name:`${unhandledErrors.length} unhandled error${unhandledErrors?.length>1?"s":""}`,message:unhandledErrors.map((e,index)=>`[${index}]: ${e.stack||e.message}`).join(`
----------
`)};this.sendReport({providerId:TEST_PROVIDER_ID,status:"failed",details:report.details,progress:report.progress,error});}else this.sendReport({providerId:TEST_PROVIDER_ID,status:"success",...report});this.clearVitestState();}};var VitestManager=class{constructor(channel2,testManager){this.channel=channel2;this.testManager=testManager;this.vitest=null;this.vitestStartupCounter=0;}async startVitest(watchMode=!1){let{createVitest}=await import('vitest/node');this.vitest=await createVitest("test",{watch:watchMode,passWithNoTests:!1,changed:watchMode,reporters:["default",new StorybookReporter(this.testManager)],coverage:{enabled:!1}}),this.vitest&&this.vitest.onCancel(()=>{}),await this.vitest.init(),watchMode&&await this.setupWatchers();}async runAllTests(){this.vitest||await this.startVitest();let storybookTests=await this.getStorybookTestSpecs();for(let storybookTest of storybookTests)this.testManager.watchMode||this.updateLastChanged(storybookTest.moduleId);await this.cancelCurrentRun(),await this.vitest.runFiles(storybookTests,!0);}updateLastChanged(filepath){this.vitest.getModuleProjects(filepath).forEach(({server,browser})=>{server.moduleGraph.getModulesByFile(filepath)?.forEach(mod=>server.moduleGraph.invalidateModule(mod)),browser&&browser.vite.moduleGraph.getModulesByFile(filepath)?.forEach(mod=>browser.vite.moduleGraph.invalidateModule(mod));});}async runTests(testPayload){this.vitest||await this.startVitest();let testList=[],storybookTests=await this.getStorybookTestSpecs();for(let storybookTest of storybookTests)testPayload.find(test=>path.join(process.cwd(),test.importPath)===storybookTest.moduleId)&&(this.testManager.watchMode||this.updateLastChanged(storybookTest.moduleId),testList.push(storybookTest));await this.cancelCurrentRun(),await this.vitest.runFiles(testList,!0);}async cancelCurrentRun(){await this.vitest?.cancelCurrentRun("keyboard-input"),await this.vitest?.runningPromise;}async closeVitest(){await this.vitest?.close();}async getStorybookTestSpecs(){return (await this.vitest?.globTestSpecs()??[]).filter(workspaceSpec=>this.isStorybookProject(workspaceSpec.project))??[]}async getTestDependencies(spec,deps=new Set){let addImports=async(project,filepath)=>{if(deps.has(filepath))return;deps.add(filepath);let transformed=project.server.moduleGraph.getModuleById(filepath)?.ssrTransformResult||await project.vitenode.transformRequest(filepath);if(!transformed)return;let dependencies=[...transformed.deps||[],...transformed.dynamicDeps||[]];await Promise.all(dependencies.map(async dep=>{let idPath=await project.server.pluginContainer.resolveId(dep,filepath,{ssr:!0}),fsPath=idPath&&!idPath.external&&idPath.id.split("?")[0];fsPath&&!fsPath.includes("node_modules")&&!deps.has(fsPath)&&existsSync(fsPath)&&await addImports(project,fsPath);}));};return await addImports(spec.project.workspaceProject,spec.moduleId),deps.delete(spec.moduleId),deps}async runAffectedTests(trigger){if(!this.vitest)return;let globTestFiles=await this.vitest.globTestSpecs(),testGraphs=await Promise.all(globTestFiles.filter(workspace=>this.isStorybookProject(workspace.project)).map(async spec=>{let deps=await this.getTestDependencies(spec);return [spec,deps]})),triggerAffectedTests=[];for(let[workspaceSpec,deps]of testGraphs)trigger&&(trigger===workspaceSpec.moduleId||deps.has(trigger))&&triggerAffectedTests.push(workspaceSpec);triggerAffectedTests.length&&(await this.vitest.cancelCurrentRun("keyboard-input"),await this.vitest.runningPromise,await this.vitest.runFiles(triggerAffectedTests,!0));}async runAffectedTestsAfterChange(file){let id=slash(file);this.vitest?.logger.clearHighlightCache(id),this.updateLastChanged(id),await this.runAffectedTests(file);}async registerVitestConfigListener(){this.vitest?.server?.watcher.on("change",async file=>{file=normalize(file),file===this.vitest.server.config.configFile&&(log("Restarting Vitest due to config change"),await this.closeVitest(),await this.startVitest());});}async setupWatchers(){this.vitest?.server?.watcher.removeAllListeners("change"),this.vitest?.server?.watcher.removeAllListeners("add"),this.vitest?.server?.watcher.on("change",this.runAffectedTestsAfterChange.bind(this)),this.vitest?.server?.watcher.on("add",this.runAffectedTestsAfterChange.bind(this)),this.registerVitestConfigListener();}isStorybookProject(project){return !!project.config.env?.__STORYBOOK_URL__}};var TestManager=class _TestManager{constructor(channel2,options={}){this.channel=channel2;this.options=options;this.watchMode=!1;this.vitestManager=new VitestManager(channel2,this),this.channel.on(TESTING_MODULE_RUN_REQUEST,this.handleRunRequest.bind(this)),this.channel.on(TESTING_MODULE_RUN_ALL_REQUEST,this.handleRunAllRequest.bind(this)),this.channel.on(TESTING_MODULE_WATCH_MODE_REQUEST,this.handleWatchModeRequest.bind(this)),this.channel.on(TESTING_MODULE_CANCEL_TEST_RUN_REQUEST,this.handleCancelRequest.bind(this)),this.vitestManager.startVitest().then(()=>options.onReady?.());}async restartVitest(watchMode=!1){await this.vitestManager.vitest?.runningPromise,await this.vitestManager.closeVitest(),await this.vitestManager.startVitest(watchMode);}async handleWatchModeRequest(request){try{if(request.providerId!==TEST_PROVIDER_ID)return;this.watchMode!==request.watchMode&&(this.watchMode=request.watchMode,await this.restartVitest(this.watchMode));}catch(e){this.reportFatalError("Failed to change watch mode",e);}}async handleRunRequest(request){try{if(request.providerId!==TEST_PROVIDER_ID)return;await this.vitestManager.runTests(request.payload);}catch(e){this.reportFatalError("Failed to run tests",e);}}async handleRunAllRequest(request){try{if(request.providerId!==TEST_PROVIDER_ID)return;await this.vitestManager.runAllTests();}catch(e){this.reportFatalError("Failed to run all tests",e);}}async handleCancelRequest(request){try{if(request.providerId!==TEST_PROVIDER_ID)return;await this.vitestManager.cancelCurrentRun();}catch(e){this.reportFatalError("Failed to cancel tests",e);}}async sendProgressReport(payload){this.channel.emit(TESTING_MODULE_PROGRESS_REPORT,payload);}async reportFatalError(message,error){this.options.onError?.(message,error);}static async start(channel2,options={}){return new Promise(resolve=>{let testManager=new _TestManager(channel2,{...options,onReady:()=>{resolve(testManager),options.onReady?.();}});})}};process2.env.TEST="true";process2.env.VITEST="true";process2.env.NODE_ENV??="test";var channel=new Channel({async:!0,transport:{send:event=>{process2.send?.(event);},setHandler:handler=>{process2.on("message",handler);}}});new TestManager(channel,{onError:(message,error)=>{process2.send?.({type:"error",message,error:error.stack??error});},onReady:()=>{process2.send?.({type:"ready"});}});var exit=(code=0)=>{channel?.removeAllListeners(),process2.exit(code);};process2.on("exit",exit);process2.on("SIGINT",()=>exit(0));process2.on("SIGTERM",()=>exit(0));process2.on("uncaughtException",err=>{process2.send?.({type:"error",message:"Uncaught exception",error:err.stack}),exit(1);});process2.on("unhandledRejection",reason=>{process2.send?.({type:"error",message:"Unhandled rejection",error:String(reason)}),exit(1);});
