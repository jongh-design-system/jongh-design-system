var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { g as getBrowserState, a as getConfig } from "./utils-CUwLt_eT.js";
import { client, channel, globalChannel } from "@vitest/browser/client";
const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _ROOT_FOLDER_RE = /^\/([A-Za-z]:)?$/;
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
const resolve = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
    const path = index >= 0 ? arguments_[index] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index = 0; index <= path.length; ++index) {
    if (index < path.length) {
      char = path[index];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index)}`;
        } else {
          res = path.slice(lastSlash + 1, index);
        }
        lastSegmentLength = index - lastSlash - 1;
      }
      lastSlash = index;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const isAbsolute = function(p) {
  return _IS_ABSOLUTE_RE.test(p);
};
const relative = function(from, to) {
  const _from = resolve(from).replace(_ROOT_FOLDER_RE, "$1").split("/");
  const _to = resolve(to).replace(_ROOT_FOLDER_RE, "$1").split("/");
  if (_to[0][1] === ":" && _from[0][1] === ":" && _from[0] !== _to[0]) {
    return _to.join("/");
  }
  const _fromCopy = [..._from];
  for (const segment of _fromCopy) {
    if (_to[0] !== segment) {
      break;
    }
    _from.shift();
    _to.shift();
  }
  return [..._from.map(() => ".."), ..._to].join("/");
};
function generateHash(str) {
  let hash = 0;
  if (str.length === 0) {
    return `${hash}`;
  }
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return `${hash}`;
}
function getUiAPI() {
  return window.__vitest_ui_api__;
}
const url = new URL(location.href);
const ID_ALL = "__vitest_all__";
class IframeOrchestrator {
  constructor() {
    __publicField(this, "cancelled", false);
    __publicField(this, "runningFiles", /* @__PURE__ */ new Set());
    __publicField(this, "iframes", /* @__PURE__ */ new Map());
  }
  async init() {
    const testFiles = getBrowserState().files;
    debug("test files", testFiles.join(", "));
    this.runningFiles.clear();
    testFiles.forEach((file) => this.runningFiles.add(file));
    channel.addEventListener(
      "message",
      (e) => this.onIframeEvent(e)
    );
    globalChannel.addEventListener(
      "message",
      (e) => this.onGlobalChannelEvent(e)
    );
  }
  async createTesters(testFiles) {
    this.cancelled = false;
    this.runningFiles.clear();
    testFiles.forEach((file) => this.runningFiles.add(file));
    const config = getConfig();
    const container = await getContainer(config);
    if (config.browser.ui) {
      container.className = "absolute origin-top mt-[8px]";
      container.parentElement.setAttribute("data-ready", "true");
      container.textContent = "";
    }
    const { width, height } = config.browser.viewport;
    this.iframes.forEach((iframe) => iframe.remove());
    this.iframes.clear();
    if (config.isolate === false) {
      const iframe = this.createIframe(container, ID_ALL);
      await setIframeViewport(iframe, width, height);
      return;
    }
    for (const file of testFiles) {
      if (this.cancelled) {
        done();
        return;
      }
      const iframe = this.createIframe(container, file);
      await setIframeViewport(iframe, width, height);
      await new Promise((resolve2) => {
        channel.addEventListener(
          "message",
          function handler(e) {
            if (e.data.type === "done" || e.data.type === "error") {
              channel.removeEventListener("message", handler);
              resolve2();
            }
          }
        );
      });
    }
  }
  createIframe(container, file) {
    if (this.iframes.has(file)) {
      this.iframes.get(file).remove();
      this.iframes.delete(file);
    }
    const iframe = document.createElement("iframe");
    iframe.setAttribute("loading", "eager");
    iframe.setAttribute(
      "src",
      `${url.pathname}__vitest_test__/__test__/${getBrowserState().contextId}/${encodeURIComponent(file)}`
    );
    iframe.setAttribute("data-vitest", "true");
    iframe.style.border = "none";
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.setAttribute("allowfullscreen", "true");
    iframe.setAttribute("allow", "clipboard-write;");
    iframe.setAttribute("name", "vitest-iframe");
    this.iframes.set(file, iframe);
    container.appendChild(iframe);
    return iframe;
  }
  async onGlobalChannelEvent(e) {
    debug("global channel event", JSON.stringify(e.data));
    switch (e.data.type) {
      case "cancel": {
        this.cancelled = true;
        break;
      }
    }
  }
  async onIframeEvent(e) {
    var _a;
    debug("iframe event", JSON.stringify(e.data));
    switch (e.data.type) {
      case "viewport": {
        const { width, height, id } = e.data;
        const iframe = this.iframes.get(id);
        if (!iframe) {
          const error = new Error(`Cannot find iframe with id ${id}`);
          channel.postMessage({
            type: "viewport:fail",
            id,
            error: error.message
          });
          await client.rpc.onUnhandledError(
            {
              name: "Teardown Error",
              message: error.message
            },
            "Teardown Error"
          );
          return;
        }
        await setIframeViewport(iframe, width, height);
        channel.postMessage({ type: "viewport:done", id });
        break;
      }
      case "done": {
        const filenames = e.data.filenames;
        filenames.forEach((filename) => this.runningFiles.delete(filename));
        if (!this.runningFiles.size) {
          const ui = getUiAPI();
          if (ui && filenames.length > 1) {
            const id = generateFileId(filenames[filenames.length - 1]);
            ui.setCurrentFileId(id);
          }
          await done();
        } else {
          const iframeId = e.data.id;
          (_a = this.iframes.get(iframeId)) == null ? void 0 : _a.remove();
          this.iframes.delete(iframeId);
        }
        break;
      }
      case "error": {
        const iframeId = e.data.id;
        this.iframes.delete(iframeId);
        await client.rpc.onUnhandledError(e.data.error, e.data.errorType);
        if (iframeId === ID_ALL) {
          this.runningFiles.clear();
        } else {
          this.runningFiles.delete(iframeId);
        }
        if (!this.runningFiles.size) {
          await done();
        }
        break;
      }
      default: {
        e.data;
        await client.rpc.onUnhandledError(
          {
            name: "Unexpected Event",
            message: `Unexpected event: ${e.data.type}`
          },
          "Unexpected Event"
        );
        await done();
      }
    }
  }
}
const orchestrator = new IframeOrchestrator();
let promiseTesters;
getBrowserState().createTesters = async (files) => {
  await promiseTesters;
  promiseTesters = orchestrator.createTesters(files).finally(() => {
    promiseTesters = void 0;
  });
  await promiseTesters;
};
async function done() {
  await client.rpc.finishBrowserTests(getBrowserState().contextId);
}
async function getContainer(config) {
  if (config.browser.ui) {
    const element = document.querySelector("#tester-ui");
    if (!element) {
      return new Promise((resolve2) => {
        setTimeout(() => {
          resolve2(getContainer(config));
        }, 30);
      });
    }
    return element;
  }
  return document.querySelector("#vitest-tester");
}
client.waitForConnection().then(async () => {
  const testFiles = getBrowserState().files;
  await orchestrator.init();
  if (testFiles.length) {
    await orchestrator.createTesters(testFiles);
  }
});
function generateFileId(file) {
  const config = getConfig();
  const project = config.name || "";
  const path = relative(config.root, file);
  return generateHash(`${path}${project}`);
}
async function setIframeViewport(iframe, width, height) {
  const ui = getUiAPI();
  if (ui) {
    await ui.setIframeViewport(width, height);
  } else {
    iframe.style.width = `${width}px`;
    iframe.style.height = `${height}px`;
  }
}
function debug(...args) {
  const debug2 = getConfig().env.VITEST_BROWSER_DEBUG;
  if (debug2 && debug2 !== "false") {
    client.rpc.debug(...args.map(String));
  }
}
