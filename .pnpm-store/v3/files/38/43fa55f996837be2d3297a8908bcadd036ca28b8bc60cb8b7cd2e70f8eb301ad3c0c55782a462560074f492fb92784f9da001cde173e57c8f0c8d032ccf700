import { userEvent } from '@testing-library/user-event';
import { page, server } from '@vitest/browser/context';
import { g as getByLabelSelector, a as getByRoleSelector, b as getByTestIdSelector, c as getByAltTextSelector, d as getByPlaceholderSelector, e as getByTextSelector, f as getByTitleSelector, h as getElementError } from '../public-utils-D6S2-5kI.js';
import { s as selectorEngine, L as Locator, c as convertElementToCssSelector } from '../index-Cgg35wOd.js';
import 'vitest/utils';

page.extend({
  getByLabelText(text, options) {
    return new PreviewLocator(getByLabelSelector(text, options));
  },
  getByRole(role, options) {
    return new PreviewLocator(getByRoleSelector(role, options));
  },
  getByTestId(testId) {
    return new PreviewLocator(getByTestIdSelector(server.config.browser.locators.testIdAttribute, testId));
  },
  getByAltText(text, options) {
    return new PreviewLocator(getByAltTextSelector(text, options));
  },
  getByPlaceholder(text, options) {
    return new PreviewLocator(getByPlaceholderSelector(text, options));
  },
  getByText(text, options) {
    return new PreviewLocator(getByTextSelector(text, options));
  },
  getByTitle(title, options) {
    return new PreviewLocator(getByTitleSelector(title, options));
  },
  elementLocator(element) {
    return new PreviewLocator(
      selectorEngine.generateSelectorSimple(element),
      element
    );
  }
});
class PreviewLocator extends Locator {
  constructor(_pwSelector, _container) {
    super();
    this._pwSelector = _pwSelector;
    this._container = _container;
  }
  get selector() {
    const selectors = this.elements().map((element) => convertElementToCssSelector(element));
    if (!selectors.length) {
      throw getElementError(this._pwSelector, this._container || document.body);
    }
    return selectors.join(", ");
  }
  click() {
    return userEvent.click(this.element());
  }
  dblClick() {
    return userEvent.dblClick(this.element());
  }
  tripleClick() {
    return userEvent.tripleClick(this.element());
  }
  hover() {
    return userEvent.hover(this.element());
  }
  unhover() {
    return userEvent.unhover(this.element());
  }
  async fill(text) {
    await this.clear();
    return userEvent.type(this.element(), text);
  }
  async upload(file) {
    const uploadPromise = (Array.isArray(file) ? file : [file]).map(async (file2) => {
      if (typeof file2 !== "string") {
        return file2;
      }
      const { content: base64, basename, mime } = await this.triggerCommand("__vitest_fileInfo", file2, "base64");
      const fileInstance = fetch(`data:${mime};base64,${base64}`).then((r) => r.blob()).then((blob) => new File([blob], basename, { type: mime }));
      return fileInstance;
    });
    const uploadFiles = await Promise.all(uploadPromise);
    return userEvent.upload(this.element(), uploadFiles);
  }
  selectOptions(options_) {
    const options = (Array.isArray(options_) ? options_ : [options_]).map((option) => {
      if (typeof option !== "string" && "element" in option) {
        return option.element();
      }
      return option;
    });
    return userEvent.selectOptions(this.element(), options);
  }
  async dropTo() {
    throw new Error('The "preview" provider doesn\'t support `dropTo` method.');
  }
  clear() {
    return userEvent.clear(this.element());
  }
  async screenshot() {
    throw new Error('The "preview" provider doesn\'t support `screenshot` method.');
  }
  locator(selector) {
    return new PreviewLocator(`${this._pwSelector} >> ${selector}`, this._container);
  }
  elementLocator(element) {
    return new PreviewLocator(
      selectorEngine.generateSelectorSimple(element),
      element
    );
  }
}
