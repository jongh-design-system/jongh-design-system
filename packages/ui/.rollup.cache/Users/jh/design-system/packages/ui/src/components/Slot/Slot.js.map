{"version":3,"file":"Slot.js","sourceRoot":"","sources":["Slot.tsx"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  Children,\n  HTMLAttributes,\n  ReactElement,\n  ReactNode,\n  Ref,\n  cloneElement,\n  forwardRef,\n  isValidElement,\n} from \"react\"\n\nimport Slottable from \"./Slottable\"\n\nexport interface SlotProps extends HTMLAttributes<HTMLElement> {\n  children: ReactNode\n}\n\nexport type RenderDelegationProps<T> = T & {\n  asChild?: boolean\n}\n\nfunction mergeProps(\n  slotProps: Record<string, any>,\n  childProps: Record<string, any>,\n) {\n  const overrideProps = { ...childProps }\n  for (const propName in childProps) {\n    const [slotPropValue, childPropValue] = [\n      slotProps[propName],\n      childProps[propName],\n    ]\n    const isHandler = /^on[A-Z]/.test(propName)\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          //두 핸들러 함수를 받아서 둘다 실행\n          childPropValue(...args)\n          slotPropValue(...args)\n        }\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue\n      } //childProps에 있는건 이미 들어가있음\n    }\n    if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue }\n    }\n    if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue]\n        .filter(Boolean)\n        .join(\" \")\n    }\n  }\n  return { ...slotProps, ...overrideProps }\n}\n\nfunction isSlottable(\n  child: ReactNode,\n): child is ReactElement<{ children: ReactNode }> {\n  return isValidElement(child) && child.type === Slottable\n}\n//ref는 함수일수도, 객체일수도 있음\nconst setRef = <T,>(ref: Ref<T>, value: T) => {\n  if (typeof ref === \"function\") {\n    ref(value)\n  } else if (ref !== null && ref !== undefined) {\n    ;(ref as React.MutableRefObject<T>).current = value\n  }\n}\n\nconst composeRefs = <T,>(...refs: Ref<T>[]) => {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node))\n}\n\nconst Slot = forwardRef<any, SlotProps>((props, ref) => {\n  const { children, ...slotProps } = props\n  const childrenArray = Children.toArray(children)\n  const slottable = childrenArray.find(isSlottable)\n\n  if (slottable) {\n    const newElement = slottable.props.children\n    //'Slottable' 컴포넌트의 자식\n    const newChildren = childrenArray.map((child) => {\n      //'Slot' 컴포넌트의 children\n      if (child !== slottable) return child\n      //'Slottable'이 아니라면 그대로 리턴\n      if (isValidElement(newElement)) {\n        //slottable의 children의 children을 리턴해야함\n        return newElement.props.children\n      } else {\n        console.warn(\n          \"Slot component should have only one React element as a child\",\n        )\n      }\n\n      return null\n    })\n\n    return isValidElement(newElement)\n      ? cloneElement(\n          newElement,\n          {\n            ...(mergeProps(slotProps, newElement.props) as any),\n            ref: ref\n              ? composeRefs(ref, (newElement as any).ref)\n              : (newElement as any).ref,\n          },\n          newChildren,\n        )\n      : null\n  }\n  //slottable이 없을 경우\n  if (isValidElement(children)) {\n    return cloneElement(children, {\n      ...(mergeProps(slotProps, children.props) as any),\n      ref: ref\n        ? composeRefs(ref, (children as any).ref)\n        : (children as any).ref,\n    })\n  }\n\n  console.warn(\"Slot component should have only one React element as a child\")\n\n  return null\n})\n\nSlot.displayName = \"Slot\"\n\nexport default Slot\n//Slot은 전달된 props를 child에 merge하는 컴포넌트\n"]}